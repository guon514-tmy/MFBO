import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm
from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF, ConstantKernel as C

# --- 1. æ¨¡æ‹Ÿç¯å¢ƒè®¾ç½® ---

class SimulatedStamping:
    """
    æ¨¡æ‹Ÿå†²å‹å›å¼¹è¿‡ç¨‹ï¼ŒåŒ…å«ä¸€ä¸ªæœ‰åå·®çš„ä»¿çœŸæ¨¡å‹å’Œä¸€ä¸ªçœŸå®çš„å®éªŒæ¨¡å‹ã€‚
    è‡ªå˜é‡ k (è¡¥å¿ç³»æ•°)ï¼Œå› å˜é‡ Y (Nä¸ªç‚¹çš„å›å¼¹é‡)ã€‚
    """
    def __init__(self, N_points=100):
        self.N_points = N_points
        # çœŸå®å›å¼¹é‡çš„åŸºç¡€å‡½æ•° (å‡è®¾æœ€ä¼˜k=1.1æ—¶å›å¼¹é‡æœ€å°)
        self.true_base_func = lambda k: 0.8 * (k - 1.1)**2 + 0.5

    def true_experiment(self, k):
        """æ¨¡æ‹ŸçœŸå®çš„å†²å‹å®éªŒç»“æœï¼šæ˜‚è´µã€å‡†ç¡®ä½†åŒ…å«éšæœºæµ‹é‡è¯¯å·®ã€‚"""
        # 1. åŸºç¡€å›å¼¹å½¢çŠ¶ (çœŸå®å›å¼¹é‡)
        base_rebound = self.true_base_func(k)
        
        # 2. æ¨¡æ‹ŸNä¸ªç‚¹å›å¼¹é‡çš„åˆ†å¸ƒ (å‡è®¾å½¢çŠ¶ä¸ºæ­£å¼¦æ³¢ï¼Œå³°å€¼åœ¨base_rebound)
        # äº§ç”Ÿä¸€ä¸ªéškå˜åŒ–çš„å›å¼¹é‡åœº
        x = np.linspace(0, 1, self.N_points)
        field_shape = np.sin(2 * np.pi * x) * 0.2  # å½¢çŠ¶æ³¢åŠ¨
        
        # 3. æ–½åŠ éšæœºæµ‹é‡è¯¯å·® (é«˜æ–¯å™ªå£°)
        measurement_noise = np.random.normal(0, 0.05, self.N_points)
        
        # æœ€ç»ˆçœŸå®å›å¼¹é‡åœº
        E_k = base_rebound + field_shape * base_rebound + measurement_noise
        return E_k

    def simulation(self, k):
        """æ¨¡æ‹ŸAutoFormä»¿çœŸç»“æœï¼šå»‰ä»·ã€å¿«é€Ÿä½†å­˜åœ¨ç³»ç»Ÿåå·® (Bias)ã€‚"""
        # 1. ä»¿çœŸé€šå¸¸ä¼šä½ä¼°å›å¼¹é‡ (ä¾‹å¦‚åå·®å§‹ç»ˆä¸º 0.3mm)
        # 2. ä»¿çœŸæ¨¡å‹çš„å½¢çŠ¶å¯èƒ½ä¸å®Œç¾ (ä¾‹å¦‚æœ€ä¼˜kåœ¨1.0è€Œä¸æ˜¯1.1)
        sim_base_func = lambda k: 0.9 * (k - 1.0)**2 + 0.4
        
        # 3. ä»¿çœŸç»“æœ
        sim_rebound = sim_base_func(k)
        
        # 4. æ¨¡æ‹Ÿä»¿çœŸåœºçš„åˆ†å¸ƒ (ä¸çœŸå®åœºå½¢çŠ¶ç•¥æœ‰ä¸åŒ)
        x = np.linspace(0, 1, self.N_points)
        sim_field_shape = np.cos(np.pi * x) * 0.15 

        # æœ€ç»ˆä»¿çœŸå›å¼¹é‡åœº
        S_k = sim_rebound + sim_field_shape * sim_rebound 
        return S_k

# --- 2. æ ‡é‡åŒ–å¤„ç†å‡½æ•° ---

def scalarize(Y, method='max', beta=1.0):
    """
    å°†é«˜ç»´å›å¼¹é‡åœº Y (Nä¸ªç‚¹çš„å›å¼¹é‡) è½¬åŒ–ä¸ºä¸€ä¸ªæ ‡é‡å€¼ã€‚
    Args:
        Y (np.array): å›å¼¹é‡å€¼æ•°ç»„ã€‚
        method (str): 'max' (L-inf èŒƒæ•°) æˆ– 'softmax' (å¹³æ»‘æœ€å¤§å€¼)ã€‚
        beta (float): Softmaxçš„å¹³æ»‘åº¦å‚æ•° (betaè¶Šå¤§ï¼Œè¶Šæ¥è¿‘max)ã€‚
    """
    Y = np.abs(Y) # å›å¼¹é‡é€šå¸¸åªå…³æ³¨ç»å¯¹å€¼
    if method == 'max':
        return np.max(Y)
    elif method == 'softmax':
        # Softmax: log(sum(exp(beta * y_i))) / beta
        # è¿™æ˜¯ä¸€ä¸ªå¹³æ»‘çš„æœ€å¤§å€¼è¿‘ä¼¼ï¼Œæ›´å®¹æ˜“è¢«GPæ‹Ÿåˆ
        return np.log(np.sum(np.exp(beta * Y))) / beta
    else:
        raise ValueError("Method must be 'max' or 'softmax'.")

# --- 3. è´å¶æ–¯ä¼˜åŒ–æ ¸å¿ƒç»„ä»¶ ---

def ExpectedImprovement(k, mu_k, sigma_k, f_best):
    """
    è®¡ç®—é‡‡é›†å‡½æ•°ï¼šæœŸæœ›æå‡ (Expected Improvement, EI)ã€‚
    """
    # ç¡®ä¿æ–¹å·®ä¸ä¸º0ï¼Œé¿å…æ•°å€¼é”™è¯¯
    sigma_k = np.maximum(1e-10, sigma_k)
    
    Z = (f_best - mu_k) / sigma_k
    ei = sigma_k * (Z * norm.cdf(Z) + norm.pdf(Z))
    return ei

def find_next_k_EI(K_candidates, GP_model, f_best):
    """
    åœ¨å€™é€‰ç‚¹ä¸­å¯»æ‰¾æœ€å¤§åŒ– EI çš„ç‚¹ã€‚
    """
    mu_candidates, sigma_candidates = GP_model.predict(K_candidates.reshape(-1, 1), return_std=True)
    
    # EI å‡½æ•°éœ€è¦æ ‡é‡è¾“å…¥ï¼Œè¿™é‡Œä¸€æ¬¡æ€§è®¡ç®—æ‰€æœ‰å€™é€‰ç‚¹çš„EI
    ei_values = ExpectedImprovement(K_candidates, mu_candidates, sigma_candidates, f_best)
    
    # é€‰å‡ºEIæœ€å¤§çš„é‚£ä¸ªk
    next_k_index = np.argmax(ei_values)
    return K_candidates[next_k_index]

# --- 4. åå·®æ„ŸçŸ¥è´å¶æ–¯ä¼˜åŒ–ä¸»æµç¨‹ ---

def delta_correction_bo(sim_env, initial_K, n_iterations, k_bounds=(0.7, 1.3)):
    """
    åå·®æ ¡æ­£è´å¶æ–¯ä¼˜åŒ–ä¸»å‡½æ•°ã€‚
    """
    # åˆå§‹åŒ–æ•°æ®è®°å½•
    K_sim = []     # ä»¿çœŸè¡¥å¿ç³»æ•°
    Y_sim = []     # ä»¿çœŸæ ‡é‡å›å¼¹é‡ (å»‰ä»·)
    K_exp = initial_K.copy() # å®éªŒè¡¥å¿ç³»æ•°
    Y_exp = []     # å®éªŒæ ‡é‡å›å¼¹é‡ (æ˜‚è´µ)
    
    # 1. ç”Ÿæˆåˆå§‹çš„ä»¿çœŸæ•°æ® (å¯†é›†é‡‡æ ·)
    K_sim = np.linspace(k_bounds[0], k_bounds[1], 50) 
    for k in K_sim:
        S_k = sim_env.simulation(k)
        Y_sim.append(scalarize(S_k, method='softmax', beta=10))

    Y_sim = np.array(Y_sim)
    
    # 2. æ”¶é›†åˆå§‹å®éªŒæ•°æ® (ä½ çš„å·²çŸ¥ç‚¹)
    for k in initial_K:
        E_k = sim_env.true_experiment(k)
        Y_exp.append(scalarize(E_k, method='softmax', beta=10))
        
    Y_exp = np.array(Y_exp)
    
    print(f"--- åˆå§‹æ•°æ® (n={len(initial_K)}) ---")
    print(f"k: {initial_K}")
    print(f"å®éªŒå›å¼¹: {Y_exp.round(3)}")
    print("-" * 30)

    # 3. è´å¶æ–¯ä¼˜åŒ–è¿­ä»£
    for i in range(n_iterations):
        
        # 3.1. è®¡ç®—åå·® (Delta)
        # æ‰¾åˆ°ä¸å®éªŒ k ç‚¹æœ€è¿‘çš„ä»¿çœŸ k ç‚¹ï¼ˆè¿™é‡Œå‡è®¾K_expä¹Ÿåœ¨K_simä¸­ï¼Œç®€åŒ–å¤„ç†ï¼‰
        delta_y = []
        for k_i, y_exp_i in zip(K_exp, Y_exp):
            idx = np.argmin(np.abs(K_sim - k_i)) # æ‰¾åˆ°æœ€æ¥è¿‘çš„ä»¿çœŸç‚¹ç´¢å¼•
            y_sim_i = Y_sim[idx]
            delta_y.append(y_exp_i - y_sim_i)
            
        delta_y = np.array(delta_y)
        
        # 3.2. å»ºç«‹åå·®æ¨¡å‹ (é«˜æ–¯è¿‡ç¨‹)
        kernel = C(1.0, (1e-3, 1e3)) * RBF(1.0, (1e-2, 1e2))
        gp_delta = GaussianProcessRegressor(kernel=kernel, alpha=1e-6, n_restarts_optimizer=10)
        
        # è®­ç»ƒ GP æ¨¡å‹æ¥é¢„æµ‹åå·®
        gp_delta.fit(K_exp.reshape(-1, 1), delta_y)
        
        # 3.3. å»ºç«‹çœŸå®å›å¼¹é¢„æµ‹æ¨¡å‹
        # çœŸå®å›å¼¹ = ä»¿çœŸ + åå·®é¢„æµ‹
        mu_delta, sigma_delta = gp_delta.predict(K_sim.reshape(-1, 1), return_std=True)
        mu_real = Y_sim + mu_delta # ä¿®æ­£åçš„çœŸå®å›å¼¹é¢„æµ‹å‡å€¼
        sigma_real = sigma_delta   # é¢„æµ‹çœŸå®å›å¼¹çš„ä¸ç¡®å®šæ€§ä¸»è¦æ¥è‡ªåå·®çš„ä¸ç¡®å®šæ€§

        # 3.4. å¯»æ‰¾å½“å‰æœ€ä½³è§‚æµ‹å€¼ (f_best)
        # f_bestæ˜¯åˆ°ç›®å‰ä¸ºæ­¢æ‰€æœ‰å®éªŒç‚¹ä¸­çš„æœ€å°å€¼
        f_best = np.min(Y_exp) 
        
        # 3.5. å¯»æ‰¾ä¸‹ä¸€ä¸ªé‡‡æ ·ç‚¹ k_next
        K_candidates = np.linspace(k_bounds[0], k_bounds[1], 100).reshape(-1, 1) # å€™é€‰ç‚¹
        k_next = find_next_k_EI(K_candidates, gp_delta, f_best)
        
        # 3.6. æ‰§è¡Œä¸‹ä¸€è½®å®éªŒ (æ¨¡æ‹Ÿæ˜‚è´µé‡‡æ ·)
        E_next = sim_env.true_experiment(k_next)
        Y_next = scalarize(E_next, method='softmax', beta=10)
        
        # 3.7. æ›´æ–°æ•°æ®é›†
        K_exp = np.append(K_exp, k_next)
        Y_exp = np.append(Y_exp, Y_next)
        
        # 3.8. ç»“æœæ±‡æŠ¥
        print(f"è¿­ä»£ {i+1}:")
        print(f"  å»ºè®®è¡¥å¿ç³»æ•° k_next = {k_next.round(4)}")
        print(f"  çœŸå®å›å¼¹é‡ Y_next = {Y_next.round(4)}")
        print(f"  å½“å‰æœ€ä½³å›å¼¹é‡ f_best = {np.min(Y_exp).round(4)}")
        if Y_next == f_best:
            print("  ğŸ‰ æ‰¾åˆ°æ–°çš„æœ€ä½³ç‚¹!")
        
        # ç»˜å›¾
        plt.figure(figsize=(10, 6))
        plt.plot(K_sim, Y_sim, 'b--', label='ä»¿çœŸé¢„æµ‹ (S(k))')
        plt.errorbar(K_exp, Y_exp, fmt='ro', capsize=5, label='çœŸå®å®éªŒæ•°æ® (E(k))')
        plt.plot(K_sim, mu_real, 'g-', label='GPä¿®æ­£çš„çœŸå®é¢„æµ‹ (S(k) + $\delta_{GP}$(k))')
        
        # ç»˜åˆ¶ä¸ç¡®å®šæ€§åŒºåŸŸ
        plt.fill_between(K_sim, mu_real - 1.96 * sigma_real, mu_real + 1.96 * sigma_real, 
                         alpha=0.2, color='g', label='95% ç½®ä¿¡åŒºé—´')
        
        # ç»˜åˆ¶ä¸‹ä¸€ä¸ªé‡‡æ ·ç‚¹
        plt.axvline(x=k_next, color='gray', linestyle=':', label='ä¸‹ä¸€ä¸ªé‡‡æ ·ç‚¹ $k_{next}$')
        
        # ç»˜åˆ¶ç›®æ ‡é˜ˆå€¼
        threshold = 0.55 # å‡è®¾æˆ‘ä»¬æœŸæœ›çš„å›å¼¹é‡é˜ˆå€¼
        plt.axhline(y=threshold, color='r', linestyle='--', label=f'ç›®æ ‡é˜ˆå€¼: {threshold}')

        plt.title(f'è¿­ä»£ {i+1}: åå·®æ„ŸçŸ¥è´å¶æ–¯ä¼˜åŒ–')
        plt.xlabel('å›å¼¹è¡¥å¿ç³»æ•° k')
        plt.ylabel('æœ€å¤§å›å¼¹é‡ Y (mm)')
        plt.legend()
        plt.grid(True)
        plt.show()
        
    return K_exp, Y_exp
    
# --- 5. è¿è¡Œä¸»ç¨‹åº ---

if __name__ == '__main__':
    # å®ä¾‹åŒ–æ¨¡æ‹Ÿç¯å¢ƒ
    stamping_env = SimulatedStamping(N_points=100)
    
    # å‡è®¾ä½ å·²æœ‰çš„å®éªŒæ•°æ®ç‚¹ (ä¸å¯å˜)
    initial_K = np.array([0.8, 1.0, 1.2]) 
    
    # è®¾ç½®è¿­ä»£æ¬¡æ•° (ä½ åªèƒ½åšè¿™ä¹ˆå¤šæ¬¡å®éªŒ)
    n_bo_iterations = 5 

    # è¿è¡Œè´å¶æ–¯ä¼˜åŒ–
    final_K, final_Y = delta_correction_bo(stamping_env, initial_K, n_bo_iterations)

    print("\n--- ä¼˜åŒ–ç»“æœæ€»ç»“ ---")
    best_index = np.argmin(final_Y)
    print(f"æ€»å…±è¿›è¡Œçš„å®éªŒæ¬¡æ•°: {len(final_K)}")
    print(f"æœ€ä½³è¡¥å¿ç³»æ•° k*: {final_K[best_index].round(4)}")
    print(f"å¯¹åº”çš„çœŸå®å›å¼¹é‡: {final_Y[best_index].round(4)} mm")
    print("--------------------")
